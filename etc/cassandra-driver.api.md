## API Report File for "cassandra-driver"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ConnectionOptions } from 'tls';
import EventEmitter from 'events';
import { EventEmitter as EventEmitter_2 } from 'stream';
import { default as Long } from 'long';
import * as Long_2 from 'long';
import Long__default from 'long';
import { Readable } from 'stream';
import { Socket } from 'net';

// @public (undocumented)
export const addressResolution: {
    AddressTranslator: typeof AddressTranslator;
    EC2MultiRegionTranslator: typeof EC2MultiRegionTranslator;
};

// @public
export class AddressTranslator {
    translate(address: string, port: number, callback: Function): void;
}

// @public
export class Aggregate {
    // @internal
    constructor();
    argumentTypes: Array<{
        code: number;
        info?: (object | Array<any> | string);
    }>;
    deterministic: boolean;
    finalFunction: string;
    initCondition: string;
    // @internal (undocumented)
    initConditionRaw: any;
    keyspaceName: string;
    // @internal
    name: string;
    returnType: {
        code: number;
        info?: (object | Array<any> | string);
    };
    signature: Array<string>;
    stateFunction: string;
    stateType: {
        code: number;
        info?: (object | Array<any> | string);
    };
}

// @public
export class AllowListPolicy extends LoadBalancingPolicy {
    constructor(childPolicy: LoadBalancingPolicy, allowList: Array<string>);
    getDistance(host: Host): distance;
    getOptions(): Map<string, any>;
    // Warning: (ae-forgotten-export) The symbol "EmptyCallback" needs to be exported by the entry point cassandra-rollup.d.ts
    //
    // (undocumented)
    init(client: Client, hosts: HostMap, callback: EmptyCallback): void;
    // @internal
    newQueryPlan(keyspace: string, info: ExecutionOptions, callback: (error: Error, iterator: Iterator<Host>) => void): void;
}

// @public
export class ArgumentError extends DriverError {
    constructor(message: string);
}

// @public
export function asDouble(value: number): object;

// @public
export function asFloat(value: number): object;

// @public
export function asInt(value: number): object;

// @public
export function asTimestamp(value: Date): object;

// @public
export function asUdt(value: object, udtInfo: {
    name: string;
    keyspace: string;
    fields: Array<any>;
}): object;

// @public
export const auth: {
    Authenticator: typeof Authenticator;
    AuthProvider: typeof AuthProvider;
    DseGssapiAuthProvider: typeof DseGssapiAuthProvider;
    DsePlainTextAuthProvider: typeof DsePlainTextAuthProvider;
    NoAuthProvider: typeof NoAuthProvider;
    PlainTextAuthProvider: typeof PlainTextAuthProvider;
};

// @public
export class AuthenticationError extends DriverError {
    constructor(message: string);
    // (undocumented)
    additionalInfo: ResponseError;
}

// @public
export class Authenticator {
    evaluateChallenge(challenge: Buffer, callback: Function): void;
    initialResponse(callback: Function): void;
    onAuthenticationSuccess(token?: Buffer): void;
}

// @public
export class AuthProvider {
    newAuthenticator(endpoint: string, name: string): Authenticator;
}

// @public
export class BigDecimal {
    constructor(unscaledValue: Integer | number, scale: number);
    add(other: BigDecimal): BigDecimal;
    compare(other: BigDecimal): number;
    equals(other: BigDecimal): boolean;
    static fromBuffer(buf: Buffer): BigDecimal;
    static fromNumber(value: number): BigDecimal;
    static fromString(value: string): BigDecimal;
    greaterThan(other: BigDecimal): boolean;
    // @internal (undocumented)
    inspect(): string;
    isNegative(): boolean;
    isZero(): boolean;
    // (undocumented)
    notEquals(other: BigDecimal): boolean;
    subtract(other: BigDecimal): BigDecimal;
    static toBuffer(value: BigDecimal): Buffer;
    toJSON(): string;
    toNumber(): number;
    toString(): string;
}

// @public
export class BusyConnectionError extends DriverError {
    constructor(address: string, maxRequestsPerConnection: number, connectionLength: number);
}

// @public (undocumented)
const cassandra: {
    Client: typeof Client;
    ExecutionProfile: typeof ExecutionProfile;
    ExecutionOptions: typeof ExecutionOptions;
    types: {
        getDataTypeNameByCode: typeof getDataTypeNameByCode;
        FrameHeader: typeof FrameHeader;
        generateTimestamp: typeof generateTimestamp;
        opcodes: {
            error: number;
            startup: number;
            ready: number;
            authenticate: number;
            credentials: number;
            options: number;
            supported: number;
            query: number;
            result: number;
            prepare: number;
            execute: number;
            register: number;
            event: number;
            batch: number;
            authChallenge: number;
            authResponse: number;
            authSuccess: number;
            cancel: number;
            isInRange: (code: any) => boolean;
        };
        consistencies: typeof consistencies;
        consistencyToString: {};
        dataTypes: typeof dataTypes;
        distance: typeof distance;
        frameFlags: {
            compression: number;
            tracing: number;
            customPayload: number;
            warning: number;
        };
        protocolEvents: {
            topologyChange: string;
            statusChange: string;
            schemaChange: string;
        };
        protocolVersion: typeof protocolVersion;
        responseErrorCodes: typeof responseErrorCodes;
        resultKind: {
            voidResult: number;
            rows: number;
            setKeyspace: number;
            prepared: number;
            schemaChange: number;
        };
        timeuuid: typeof timeuuid;
        uuid: typeof uuid;
        BigDecimal: typeof BigDecimal;
        Duration: typeof Duration;
        InetAddress: typeof InetAddress;
        Integer: typeof Integer;
        LocalDate: typeof LocalDate;
        LocalTime: typeof LocalTime;
        Long: typeof Long_2.default;
        ResultSet: typeof ResultSet;
        ResultStream: typeof ResultStream;
        Row: typeof Row;
        DriverError: typeof DriverError;
        TimeoutError: typeof TimeoutError;
        TimeUuid: typeof TimeUuid;
        Tuple: typeof Tuple;
        Uuid: typeof Uuid;
        unset: Readonly<{
            readonly unset: true;
        }>;
        Vector: typeof Vector;
    };
    errors: {
        ArgumentError: typeof ArgumentError;
        AuthenticationError: typeof AuthenticationError;
        BusyConnectionError: typeof BusyConnectionError;
        DriverError: typeof DriverError;
        OperationTimedOutError: typeof OperationTimedOutError;
        DriverInternalError: typeof DriverInternalError;
        NoHostAvailableError: typeof NoHostAvailableError;
        NotSupportedError: typeof NotSupportedError;
        ResponseError: typeof ResponseError;
        VIntOutOfRangeException: typeof VIntOutOfRangeException;
    };
    policies: {
        addressResolution: {
            AddressTranslator: typeof AddressTranslator;
            EC2MultiRegionTranslator: typeof EC2MultiRegionTranslator;
        };
        loadBalancing: {
            AllowListPolicy: typeof AllowListPolicy;
            DCAwareRoundRobinPolicy: typeof DCAwareRoundRobinPolicy;
            DefaultLoadBalancingPolicy: typeof DefaultLoadBalancingPolicy;
            LoadBalancingPolicy: typeof LoadBalancingPolicy;
            RoundRobinPolicy: typeof RoundRobinPolicy;
            TokenAwarePolicy: typeof TokenAwarePolicy;
            WhiteListPolicy: typeof WhiteListPolicy;
        };
        reconnection: {
            ReconnectionPolicy: typeof ReconnectionPolicy;
            ConstantReconnectionPolicy: typeof ConstantReconnectionPolicy;
            ExponentialReconnectionPolicy: typeof ExponentialReconnectionPolicy;
        };
        retry: {
            IdempotenceAwareRetryPolicy: typeof IdempotenceAwareRetryPolicy;
            FallthroughRetryPolicy: typeof FallthroughRetryPolicy;
            RetryPolicy: typeof RetryPolicy;
        };
        speculativeExecution: {
            NoSpeculativeExecutionPolicy: typeof NoSpeculativeExecutionPolicy;
            SpeculativeExecutionPolicy: typeof SpeculativeExecutionPolicy;
            ConstantSpeculativeExecutionPolicy: typeof ConstantSpeculativeExecutionPolicy;
        };
        timestampGeneration: {
            TimestampGenerator: typeof TimestampGenerator;
            MonotonicTimestampGenerator: typeof MonotonicTimestampGenerator;
        };
        defaultAddressTranslator: () => AddressTranslator;
        defaultLoadBalancingPolicy: (localDc?: string) => LoadBalancingPolicy;
        defaultRetryPolicy: () => RetryPolicy;
        defaultReconnectionPolicy: () => ReconnectionPolicy;
        defaultSpeculativeExecutionPolicy: () => SpeculativeExecutionPolicy;
        defaultTimestampGenerator: () => TimestampGenerator;
    };
    auth: {
        NoAuthProvider: typeof NoAuthProvider;
        Authenticator: typeof Authenticator;
        AuthProvider: typeof AuthProvider;
        DseGssapiAuthProvider: typeof DseGssapiAuthProvider;
        DsePlainTextAuthProvider: typeof DsePlainTextAuthProvider;
        PlainTextAuthProvider: typeof PlainTextAuthProvider;
    };
    mapping: {
        Mapper: typeof Mapper;
        ModelMapper: typeof ModelMapper;
        ModelBatchMapper: typeof ModelBatchMapper;
        ModelBatchItem: typeof ModelBatchItem;
        Result: typeof Result;
        TableMappings: typeof TableMappings;
        DefaultTableMappings: typeof DefaultTableMappings;
        UnderscoreCqlToCamelCaseMappings: typeof UnderscoreCqlToCamelCaseMappings;
        q: {
            in_: (arr: any) => QueryOperator;
            gt: (value: any) => QueryOperator;
            gte: (value: any) => QueryOperator;
            lt: (value: any) => QueryOperator;
            lte: (value: any) => QueryOperator;
            notEq: (value: any) => QueryOperator;
            and: (condition1: any, condition2: any) => QueryOperator;
            incr: (value: any) => QueryAssignment;
            decr: (value: any) => QueryAssignment;
            append: (value: any) => QueryAssignment;
            prepend: (value: any) => QueryAssignment;
            remove: (value: any) => QueryAssignment;
        };
    };
    tracker: {
        RequestTracker: typeof RequestTracker;
        RequestLogger: typeof RequestLogger;
    };
    metrics: {
        ClientMetrics: typeof ClientMetrics;
        DefaultMetrics: typeof DefaultMetrics;
    };
    concurrent: {
        executeConcurrent: typeof executeConcurrent;
        ResultSetGroup: typeof ResultSetGroup;
    };
    token: {
        Token: typeof Token;
        TokenRange: typeof TokenRange;
    };
    metadata: {
        Metadata: typeof Metadata;
    };
    Encoder: typeof Encoder;
    geometry: {
        Point: typeof Point;
        LineString: typeof LineString;
        Polygon: typeof Polygon;
        Geometry: typeof Geometry;
    };
    datastax: {
        graph: {
            getCustomTypeSerializers: typeof getCustomTypeSerializers;
            GraphTypeWrapper: typeof GraphTypeWrapper;
            UdtGraphWrapper: typeof UdtGraphWrapper;
            Edge: typeof Edge;
            Element: typeof Element;
            Path: typeof Path;
            Property: typeof Property;
            Vertex: typeof Vertex;
            VertexProperty: typeof VertexProperty;
            asInt: typeof asInt;
            asDouble: typeof asDouble;
            asFloat: typeof asFloat;
            asTimestamp: typeof asTimestamp;
            asUdt: typeof asUdt;
            direction: {
                both: {
                    typeName: any;
                    elementName: any;
                    toString(): any;
                };
                in: {
                    typeName: any;
                    elementName: any;
                    toString(): any;
                };
                out: {
                    typeName: any;
                    elementName: any;
                    toString(): any;
                };
                in_: {
                    typeName: any;
                    elementName: any;
                    toString(): any;
                };
            };
            GraphResultSet: typeof GraphResultSet;
            t: {
                id: {
                    typeName: any;
                    elementName: any;
                    toString(): any;
                };
                key: {
                    typeName: any;
                    elementName: any;
                    toString(): any;
                };
                label: {
                    typeName: any;
                    elementName: any;
                    toString(): any;
                };
                value: {
                    typeName: any;
                    elementName: any;
                    toString(): any;
                };
            };
        };
        search: {
            DateRange: typeof DateRange;
            DateRangeBound: typeof DateRangeBound;
            dateRangePrecision: {
                readonly year: 0;
                readonly month: 1;
                readonly day: 2;
                readonly hour: 3;
                readonly minute: 4;
                readonly second: 5;
                readonly millisecond: 6;
            };
        };
    };
    defaultOptions: () => ClientOptions;
    version: string;
};
export default cassandra;

// Warning: (ae-internal-missing-underscore) The name "checkServerIdentity" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function checkServerIdentity(cert: {
    subject: {
        CN: string;
    };
    subjectaltname?: string;
}, sniAddress: string): Error | undefined;

// @public
export class Client extends EventEmitter.EventEmitter {
    // Warning: (ae-forgotten-export) The symbol "DseClientOptions" needs to be exported by the entry point cassandra-rollup.d.ts
    constructor(options: DseClientOptions);
    batch(queries: Array<string | {
        query: string;
        params?: ArrayOrObject;
    }>, options?: QueryOptions): Promise<ResultSet>;
    // (undocumented)
    batch(queries: Array<string | {
        query: string;
        params?: ArrayOrObject;
    }>, options: QueryOptions, callback: ValueCallback<ResultSet>): void;
    // (undocumented)
    batch(queries: Array<string | {
        query: string;
        params?: ArrayOrObject;
    }>, callback: ValueCallback<ResultSet>): void;
    connect(): Promise<void>;
    // (undocumented)
    connect(callback: EmptyCallback): void;
    // Warning: (ae-forgotten-export) The symbol "ControlConnection" needs to be exported by the entry point cassandra-rollup.d.ts
    //
    // @internal (undocumented)
    controlConnection: ControlConnection;
    eachRow(query: string, params: ArrayOrObject, options: QueryOptions, rowCallback: (n: number, row: Row) => void, callback?: ValueCallback<ResultSet>): void;
    // (undocumented)
    eachRow(query: string, params: ArrayOrObject, rowCallback: (n: number, row: Row) => void, callback?: ValueCallback<ResultSet>): void;
    // (undocumented)
    eachRow(query: string, rowCallback: (n: number, row: Row) => void): void;
    // Warning: (ae-forgotten-export) The symbol "ArrayOrObject" needs to be exported by the entry point cassandra-rollup.d.ts
    execute(query: string, params?: ArrayOrObject, options?: QueryOptions): Promise<ResultSet>;
    // Warning: (ae-forgotten-export) The symbol "ValueCallback" needs to be exported by the entry point cassandra-rollup.d.ts
    //
    // (undocumented)
    execute(query: string, params: ArrayOrObject, options: QueryOptions, callback: ValueCallback<ResultSet>): void;
    // (undocumented)
    execute(query: string, params: ArrayOrObject, callback: ValueCallback<ResultSet>): void;
    // (undocumented)
    execute(query: string, callback: ValueCallback<ResultSet>): void;
    // Warning: (ae-forgotten-export) The symbol "GraphQueryOptions" needs to be exported by the entry point cassandra-rollup.d.ts
    executeGraph(traversal: string, parameters: {
        [name: string]: any;
    } | undefined, options: GraphQueryOptions, callback: ValueCallback<GraphResultSet>): void;
    // (undocumented)
    executeGraph(traversal: string, parameters: {
        [name: string]: any;
    } | undefined, callback: ValueCallback<GraphResultSet>): void;
    // (undocumented)
    executeGraph(traversal: string, callback: ValueCallback<GraphResultSet>): void;
    // (undocumented)
    executeGraph(traversal: string, parameters?: {
        [name: string]: any;
    }, options?: GraphQueryOptions): Promise<GraphResultSet>;
    getReplicas(keyspace: string, token: Buffer): Array<Host>;
    getState(): ClientState;
    // Warning: (ae-forgotten-export) The symbol "Connection" needs to be exported by the entry point cassandra-rollup.d.ts
    //
    // @internal
    handleSchemaAgreementAndRefresh(connection: Connection, event: any): Promise<boolean>;
    hosts: HostMap;
    keyspace: string;
    // @internal (undocumented)
    log: any;
    metadata: Metadata;
    metrics: ClientMetrics;
    // @internal (undocumented)
    options: ClientOptions;
    // Warning: (ae-forgotten-export) The symbol "ProfileManager" needs to be exported by the entry point cassandra-rollup.d.ts
    //
    // @internal (undocumented)
    profileManager: ProfileManager;
    shutdown(): Promise<void>;
    // (undocumented)
    shutdown(callback: EmptyCallback): void;
    stream(query: string, params?: ArrayOrObject, options?: QueryOptions, callback?: EmptyCallback): ResultStream;
}

// @public
export class ClientMetrics {
    onAuthenticationError(e: AuthenticationError | Error): void;
    onClientTimeoutError(e: OperationTimedOutError): void;
    onClientTimeoutRetry(e: Error): void;
    onConnectionError(e: Error): void;
    onIgnoreError(e: Error): void;
    onOtherError(e: Error): void;
    onOtherErrorRetry(e: Error): void;
    onReadTimeoutError(e: ResponseError): void;
    onReadTimeoutRetry(e: Error): void;
    onResponse(latency: Array<number>): void;
    onSpeculativeExecution(): void;
    onSuccessfulResponse(latency: Array<number>): void;
    onUnavailableError(e: ResponseError): void;
    onUnavailableRetry(e: Error): void;
    onWriteTimeoutError(e: ResponseError): void;
    onWriteTimeoutRetry(e: Error): void;
}

// @public
export interface ClientOptions {
    // @internal (undocumented)
    applicationName?: string;
    // @internal (undocumented)
    applicationVersion?: string;
    // (undocumented)
    authProvider?: AuthProvider;
    // (undocumented)
    cloud?: {
        secureConnectBundle: string | URL;
    };
    // (undocumented)
    contactPoints?: string[];
    // (undocumented)
    credentials?: {
        username: string;
        password: string;
    };
    // (undocumented)
    encoding?: {
        map?: Function;
        set?: Function;
        copyBuffer?: boolean;
        useUndefinedAsUnset?: boolean;
        useBigIntAsLong?: boolean;
        useBigIntAsVarint?: boolean;
    };
    // @internal (undocumented)
    id?: Uuid;
    // (undocumented)
    isMetadataSyncEnabled?: boolean;
    // (undocumented)
    keyspace?: string;
    // (undocumented)
    localDataCenter?: string;
    // @internal (undocumented)
    logEmitter?: any;
    // (undocumented)
    maxPrepared?: number;
    // (undocumented)
    metrics?: ClientMetrics;
    // @internal (undocumented)
    monitorReporting?: {
        enabled?: boolean;
    };
    // (undocumented)
    policies?: {
        addressResolution?: AddressTranslator;
        loadBalancing?: LoadBalancingPolicy;
        reconnection?: ReconnectionPolicy;
        retry?: RetryPolicy;
        speculativeExecution?: SpeculativeExecutionPolicy;
        timestampGeneration?: TimestampGenerator;
    };
    // (undocumented)
    pooling?: {
        coreConnectionsPerHost?: {
            [key: number]: number;
        };
        heartBeatInterval?: number;
        maxRequestsPerConnection?: number;
        warmup?: boolean;
    };
    // (undocumented)
    prepareOnAllHosts?: boolean;
    // (undocumented)
    profiles?: ExecutionProfile[];
    // (undocumented)
    promiseFactory?: (handler: (callback: (err: Error, result?: any) => void) => void) => Promise<any>;
    // (undocumented)
    protocolOptions?: {
        maxSchemaAgreementWaitSeconds?: number;
        maxVersion?: number;
        noCompact?: boolean;
        port?: number;
    };
    // (undocumented)
    queryOptions?: QueryOptions;
    // (undocumented)
    refreshSchemaDelay?: number;
    // (undocumented)
    rePrepareOnUp?: boolean;
    // (undocumented)
    requestTracker?: RequestTracker;
    // @internal (undocumented)
    sni?: {
        address?: string;
        port?: string;
        addressResolver?: AddressResolver;
    };
    // (undocumented)
    socketOptions?: {
        coalescingThreshold?: number;
        connectTimeout?: number;
        defunctReadTimeoutThreshold?: number;
        keepAlive?: boolean;
        keepAliveDelay?: number;
        readTimeout?: number;
        tcpNoDelay?: boolean;
    };
    // (undocumented)
    sslOptions?: ConnectionOptions;
}

// @public
export class ClientState {
    // @internal
    constructor(hosts: Array<Host>, openConnections: {
        [key: string]: number;
    }, inFlightQueries: {
        [key: string]: number;
    });
    // @internal
    static from(client: Client): ClientState;
    getConnectedHosts(): Array<Host>;
    getInFlightQueries(host: Host): number;
    getOpenConnections(host: Host): number;
    toString(): string;
}

// @public (undocumented)
export interface ColumnInfo {
    // (undocumented)
    name: string;
    // (undocumented)
    type: DataTypeInfo;
}

// @public (undocumented)
export const concurrent: {
    executeConcurrent: typeof executeConcurrent;
    ResultSetGroup: typeof ResultSetGroup;
};

// @public
export enum consistencies {
    // (undocumented)
    all = 5,
    // (undocumented)
    any = 0,
    // (undocumented)
    eachQuorum = 7,
    // (undocumented)
    localOne = 10,
    // (undocumented)
    localQuorum = 6,
    // (undocumented)
    localSerial = 9,
    // (undocumented)
    one = 1,
    // (undocumented)
    quorum = 4,
    // (undocumented)
    serial = 8,
    // (undocumented)
    three = 3,
    // (undocumented)
    two = 2
}

// @public
export const consistencyToString: {};

// @public
export class ConstantReconnectionPolicy extends ReconnectionPolicy {
    constructor(delay: number);
    getOptions(): Map<string, any>;
    newSchedule(): Iterator<number>;
}

// @public
export class ConstantSpeculativeExecutionPolicy extends SpeculativeExecutionPolicy {
    constructor(delay: number, maxSpeculativeExecutions: number);
    getOptions(): Map<string, any>;
    // (undocumented)
    newPlan(keyspace: string, queryInfo: string | Array<string>): {
        nextExecution: () => number;
    };
}

// @public
export class DataCollection extends EventEmitter.EventEmitter {
    // @internal
    constructor(name: string);
    bloomFilterFalsePositiveChance: number;
    caching: string;
    clusteringKeys: ColumnInfo[];
    clusteringOrder: string[];
    columns: ColumnInfo[];
    columnsByName: {
        [key: string]: ColumnInfo;
    };
    comment: string;
    compactionClass: string;
    compactionOptions: {
        [option: string]: any;
    };
    compression: {
        class?: string;
        [option: string]: any;
    };
    crcCheckChance?: number;
    defaultTtl: number;
    extensions: {
        [option: string]: any;
    };
    gcGraceSeconds: number;
    localReadRepairChance: number;
    maxIndexInterval?: number;
    minIndexInterval?: number;
    name: string;
    nodesync?: object;
    partitionKeys: ColumnInfo[];
    populateCacheOnFlush: boolean;
    readRepairChance: number;
    speculativeRetry: string;
}

// @public
export const datastax: {
    graph: {
        Edge: typeof Edge;
        Element: typeof Element;
        Path: typeof Path;
        Property: typeof Property;
        Vertex: typeof Vertex;
        VertexProperty: typeof VertexProperty;
        asInt: typeof asInt;
        asDouble: typeof asDouble;
        asFloat: typeof asFloat;
        asTimestamp: typeof asTimestamp;
        asUdt: typeof asUdt;
        direction: {
            both: {
                typeName: any;
                elementName: any;
                toString(): any;
            };
            in: {
                typeName: any;
                elementName: any;
                toString(): any;
            };
            out: {
                typeName: any;
                elementName: any;
                toString(): any;
            };
            in_: {
                typeName: any;
                elementName: any;
                toString(): any;
            };
        };
        getCustomTypeSerializers: typeof getCustomTypeSerializers;
        GraphResultSet: typeof GraphResultSet;
        GraphTypeWrapper: typeof GraphTypeWrapper;
        t: {
            id: {
                typeName: any;
                elementName: any;
                toString(): any;
            };
            key: {
                typeName: any;
                elementName: any;
                toString(): any;
            };
            label: {
                typeName: any;
                elementName: any;
                toString(): any;
            };
            value: {
                typeName: any;
                elementName: any;
                toString(): any;
            };
        };
        UdtGraphWrapper: typeof UdtGraphWrapper;
    };
    search: {
        DateRange: typeof DateRange;
        DateRangeBound: typeof DateRangeBound;
        dateRangePrecision: {
            readonly year: 0;
            readonly month: 1;
            readonly day: 2;
            readonly hour: 3;
            readonly minute: 4;
            readonly second: 5;
            readonly millisecond: 6;
        };
    };
};

// Warning: (ae-forgotten-export) The symbol "SingleColumnInfo" needs to be exported by the entry point cassandra-rollup.d.ts
// Warning: (ae-forgotten-export) The symbol "CustomSimpleColumnInfo" needs to be exported by the entry point cassandra-rollup.d.ts
// Warning: (ae-forgotten-export) The symbol "MapColumnInfo" needs to be exported by the entry point cassandra-rollup.d.ts
// Warning: (ae-forgotten-export) The symbol "TupleColumnInfo" needs to be exported by the entry point cassandra-rollup.d.ts
// Warning: (ae-forgotten-export) The symbol "ListSetColumnInfo" needs to be exported by the entry point cassandra-rollup.d.ts
// Warning: (ae-forgotten-export) The symbol "VectorColumnInfo" needs to be exported by the entry point cassandra-rollup.d.ts
// Warning: (ae-forgotten-export) The symbol "OtherCustomColumnInfo" needs to be exported by the entry point cassandra-rollup.d.ts
// Warning: (ae-forgotten-export) The symbol "UdtColumnInfo" needs to be exported by the entry point cassandra-rollup.d.ts
// Warning: (ae-forgotten-export) The symbol "TupleListColumnInfoWithoutSubtype" needs to be exported by the entry point cassandra-rollup.d.ts
//
// @public (undocumented)
export type DataTypeInfo = SingleColumnInfo | CustomSimpleColumnInfo | MapColumnInfo | TupleColumnInfo | ListSetColumnInfo | VectorColumnInfo | OtherCustomColumnInfo | UdtColumnInfo | TupleListColumnInfoWithoutSubtype;

// @public
export enum dataTypes {
    // (undocumented)
    ascii = 1,
    // (undocumented)
    bigint = 2,
    // (undocumented)
    blob = 3,
    // (undocumented)
    boolean = 4,
    // (undocumented)
    counter = 5,
    // (undocumented)
    custom = 0,
    // (undocumented)
    date = 17,
    // (undocumented)
    decimal = 6,
    // (undocumented)
    double = 7,
    // (undocumented)
    duration = 21,
    // (undocumented)
    float = 8,
    // (undocumented)
    inet = 16,
    // (undocumented)
    int = 9,
    // (undocumented)
    list = 32,
    // (undocumented)
    map = 33,
    // (undocumented)
    set = 34,
    // (undocumented)
    smallint = 19,
    // (undocumented)
    text = 10,
    // (undocumented)
    time = 18,
    // (undocumented)
    timestamp = 11,
    // (undocumented)
    timeuuid = 15,
    // (undocumented)
    tinyint = 20,
    // (undocumented)
    tuple = 49,
    // (undocumented)
    udt = 48,
    // (undocumented)
    uuid = 12,
    // (undocumented)
    varchar = 13,
    // (undocumented)
    varint = 14
}

// @public (undocumented)
export namespace dataTypes {
    export function getByName(name: string): DataTypeInfo;
}

// @public
export class DateRange {
    constructor(lowerBound: DateRangeBound, upperBound?: DateRangeBound);
    equals(other: DateRange): boolean;
    static fromBuffer(buffer: Buffer): DateRange;
    static fromString(dateRangeString: string): DateRange;
    // (undocumented)
    lowerBound: DateRangeBound;
    // (undocumented)
    toBuffer(): any;
    toString(): string;
    // (undocumented)
    upperBound: DateRangeBound;
}

// @public
export class DateRangeBound {
    constructor(date: Date, precision: number);
    // (undocumented)
    date: Date;
    equals(other: DateRangeBound): boolean;
    static fromString(boundaryString: string): DateRangeBound;
    // @internal (undocumented)
    isUnbounded(): boolean;
    // (undocumented)
    precision: number;
    static toLowerBound(bound: DateRangeBound): DateRangeBound;
    toString(): string;
    static toUpperBound(bound: DateRangeBound): DateRangeBound;
    // @internal (undocumented)
    static unbounded: Readonly<DateRangeBound>;
}

// @public
export const dateRangePrecision: {
    readonly year: 0;
    readonly month: 1;
    readonly day: 2;
    readonly hour: 3;
    readonly minute: 4;
    readonly second: 5;
    readonly millisecond: 6;
};

// @public
export class DCAwareRoundRobinPolicy extends LoadBalancingPolicy {
    constructor(localDc?: string);
    getDistance(host: Host): distance;
    // (undocumented)
    getOptions(): Map<string, any>;
    // (undocumented)
    init(client: Client, hosts: HostMap, callback: EmptyCallback): void;
    // @internal (undocumented)
    localDc: string;
    newQueryPlan(keyspace: string, executionOptions: ExecutionOptions, callback: (error: Error, iterator: Iterator<Host>) => void): void;
}

// @public
export type DecisionInfo = {
    decision: number;
    consistency?: consistencies;
    useCurrentHost?: boolean;
};

// @public
export const defaultAddressTranslator: () => AddressTranslator;

// @public
export class DefaultLoadBalancingPolicy extends LoadBalancingPolicy {
    constructor(options?: {
        localDc?: string;
        filter?: (host: Host) => boolean;
    } | string);
    getDistance(host: Host): distance;
    getOptions(): Map<string, any>;
    init(client: Client, hosts: HostMap, callback: EmptyCallback): void;
    // @override
    newQueryPlan(keyspace: string, executionOptions: ExecutionOptions, callback: (error: Error, iterator: Iterator<Host>) => void): void;
}

// @public
export const defaultLoadBalancingPolicy: (localDc?: string) => LoadBalancingPolicy;

// @public
export class DefaultMetrics extends ClientMetrics {
    constructor();
    // (undocumented)
    errors: EventEmitter & {
        authentication: EventEmitter;
        clientTimeout: EventEmitter;
        connection: EventEmitter;
        other: EventEmitter;
        readTimeout: EventEmitter;
        unavailable: EventEmitter;
        writeTimeout: EventEmitter;
    };
    // (undocumented)
    ignoredErrors: EventEmitter;
    // @override (undocumented)
    onAuthenticationError(e: Error | AuthenticationError): void;
    // @override (undocumented)
    onClientTimeoutError(e: OperationTimedOutError): void;
    // @override (undocumented)
    onClientTimeoutRetry(e: Error): void;
    // @override (undocumented)
    onConnectionError(e: Error): void;
    // @override (undocumented)
    onIgnoreError(e: Error): void;
    // @override (undocumented)
    onOtherError(e: Error): void;
    // @override (undocumented)
    onOtherErrorRetry(e: Error): void;
    // @override (undocumented)
    onReadTimeoutError(e: ResponseError): void;
    // @override (undocumented)
    onReadTimeoutRetry(e: Error): void;
    // @override (undocumented)
    onResponse(latency: number[]): void;
    // @override (undocumented)
    onSpeculativeExecution(): void;
    // @override (undocumented)
    onSuccessfulResponse(latency: number[]): void;
    // @override (undocumented)
    onUnavailableError(e: Error): void;
    // @override (undocumented)
    onUnavailableRetry(e: Error): void;
    // @override (undocumented)
    onWriteTimeoutError(e: ResponseError): void;
    // @override (undocumented)
    onWriteTimeoutRetry(e: Error): void;
    // (undocumented)
    responses: EventEmitter & {
        success: EventEmitter;
    };
    // (undocumented)
    retries: EventEmitter & {
        clientTimeout: EventEmitter;
        other: EventEmitter;
        readTimeout: EventEmitter;
        unavailable: EventEmitter;
        writeTimeout: EventEmitter;
    };
    // (undocumented)
    speculativeExecutions: EventEmitter & {
        increment: EventEmitter;
    };
}

// @public (undocumented)
export const defaultOptions: () => ClientOptions;

// @public
export const defaultReconnectionPolicy: () => ReconnectionPolicy;

// @public
export const defaultRetryPolicy: () => RetryPolicy;

// @public
export const defaultSpeculativeExecutionPolicy: () => SpeculativeExecutionPolicy;

// @public
export class DefaultTableMappings extends TableMappings {
    constructor();
    // @override (undocumented)
    getColumnName(propName: string): string;
    // @override (undocumented)
    getPropertyName(columnName: string): string;
    newObjectInstance(): object;
}

// @public
export const defaultTimestampGenerator: () => TimestampGenerator;

// @public
export const direction: {
    both: EnumValue;
    in: EnumValue;
    out: EnumValue;
    in_: EnumValue;
};

// @public
export enum distance {
    // (undocumented)
    ignored = 2,
    // (undocumented)
    local = 0,
    // (undocumented)
    remote = 1
}

// @public
export class DriverError extends Error {
    constructor(message: string);
    // (undocumented)
    info: string;
    // (undocumented)
    innerError: any;
    // (undocumented)
    isSocketError: boolean;
    // (undocumented)
    requestNotWritten?: boolean;
}

// @public
export class DriverInternalError extends DriverError {
    constructor(message: string);
}

// @public
export class DseGssapiAuthProvider extends AuthProvider {
    constructor(gssOptions: {
        authorizationId?: string;
        service?: string;
        hostNameResolver?: Function;
        user?: string;
    });
    // @override
    newAuthenticator(endpoint: string, name: string): Authenticator;
    static reverseDnsResolver(ip: string, callback: Function): void;
    static useIpResolver(ip: string, callback: Function): void;
}

// @public
export class DsePlainTextAuthProvider extends AuthProvider {
    constructor(username: string, password: string, authorizationId?: string);
    // @override
    newAuthenticator(endpoint: string, name: string): Authenticator;
}

// @public
export class Duration {
    constructor(months: number, days: number, nanoseconds: number | Long__default);
    equals(other: Duration): boolean;
    static fromBuffer(buffer: Buffer): Duration;
    static fromString(input: string): Duration;
    toBuffer(): Buffer;
    toString(): string;
}

// @public
export class EC2MultiRegionTranslator extends AddressTranslator {
    logError(address: string, err: Error): void;
    translate(address: string, port: number, callback: Function): void;
}

// @public
export class Edge extends Element {
    constructor(id: any, outV: Vertex, outVLabel: string, label: string, inV: Vertex, inVLabel?: string, properties?: {
        [s: string]: Property;
    });
    // (undocumented)
    inV: Vertex;
    // (undocumented)
    inVLabel: string;
    // (undocumented)
    outV: Vertex;
    // (undocumented)
    outVLabel: string;
    // (undocumented)
    properties: {
        [s: string]: any;
    };
}

// @public
export abstract class Element {
    constructor(id: any, label: string);
    // (undocumented)
    id: any;
    // (undocumented)
    label: string;
}

// @public (undocumented)
export class Encoder {
    constructor(protocolVersion: number, options: ClientOptions);
    decode: (buffer: Buffer, type: DataTypeInfo) => any;
    encode: (value: any, typeInfo: DataTypeInfo | number | string) => Buffer;
    // @internal
    static guessDataType: (value: any) => DataTypeInfo | null;
    // @internal
    parseFqTypeName: (typeName: string, startIndex?: number, length?: number) => DataTypeInfo;
    // @internal
    parseKeyTypes: (typesString: string) => {
        types: Array<any>;
        isComposite: boolean;
        hasCollections: boolean;
    };
    // @internal
    parseTypeName: (keyspace: string, typeName: string, startIndex: number, length: number | null, udtResolver: Function) => Promise<DataTypeInfo>;
    // @internal (undocumented)
    protocolVersion: number;
    // @internal
    setProtocolVersion: (value: number) => void;
    // @internal
    setRoutingKeyFromMeta: (meta: any, params: Array<any>, execOptions: ExecutionOptions) => void;
    // @internal
    setRoutingKeyFromUser: (params: Array<any>, execOptions: ExecutionOptions, keys?: any) => void;
}

// @public (undocumented)
export const errors: {
    ArgumentError: typeof ArgumentError;
    AuthenticationError: typeof AuthenticationError;
    BusyConnectionError: typeof BusyConnectionError;
    DriverError: typeof DriverError;
    OperationTimedOutError: typeof OperationTimedOutError;
    DriverInternalError: typeof DriverInternalError;
    NoHostAvailableError: typeof NoHostAvailableError;
    NotSupportedError: typeof NotSupportedError;
    ResponseError: typeof ResponseError;
    VIntOutOfRangeException: typeof VIntOutOfRangeException;
};

// @public
export function executeConcurrent(client: Client, query: string, parameters: any[][] | Readable, options?: Options): Promise<ResultSetGroup>;

// @public (undocumented)
export function executeConcurrent(client: Client, queries: Array<{
    query: string;
    params: any[];
}>, options?: Options): Promise<ResultSetGroup>;

// @public
export class ExecutionOptions {
    constructor();
    // @internal
    static empty(): ExecutionOptions;
    getCaptureStackTrace(): boolean;
    getConsistency(): consistencies;
    getCustomPayload(): {
        [key: string]: any;
    };
    getFetchSize(): number;
    getFixedHost(): Host;
    getHints(): string[] | string[][];
    getKeyspace(): string;
    getLoadBalancingPolicy(): LoadBalancingPolicy;
    // @internal
    getOrGenerateTimestamp(): Long__default | null;
    getPageState(): Buffer;
    // @internal
    getPreferredHost(): Host;
    getRawQueryOptions(): QueryOptions;
    getReadTimeout(): number;
    getRetryPolicy(): RetryPolicy;
    // @internal
    getRoutingIndexes(): Array<any>;
    getRoutingKey(): Buffer | Array<Buffer>;
    // @internal
    getRoutingNames(): any;
    // @internal
    getRowCallback(): any;
    getSerialConsistency(): consistencies;
    getTimestamp(): number | Long__default | undefined | null;
    isAutoPage(): boolean;
    isBatchCounter(): boolean;
    isBatchLogged(): boolean;
    isIdempotent(): boolean;
    isPrepared(): boolean;
    isQueryTracing(): boolean;
    // @internal (undocumented)
    setHints(hints: string[]): any;
    // @internal
    setKeyspace(keyspace: string): any;
    // @internal (undocumented)
    setPageState(pageState: Buffer): any;
    // @internal
    setPreferredHost(host: Host): any;
    // @internal
    setRoutingIndexes(routingIndexes: Array<any>): any;
    // @internal
    setRoutingKey(value: any): any;
}

// @public
export class ExecutionProfile {
    constructor(name: string, options?: {
        consistency?: consistencies;
        loadBalancing?: LoadBalancingPolicy;
        readTimeout?: number;
        retry?: RetryPolicy;
        serialConsistency?: consistencies;
        graphOptions?: {
            name?: string;
            language?: string;
            source?: string;
            readConsistency?: consistencies;
            writeConsistency?: consistencies;
        };
    });
    consistency?: consistencies;
    graphOptions?: {
        name?: string;
        language?: string;
        source?: string;
        readConsistency?: consistencies;
        writeConsistency?: consistencies;
        results?: any;
    };
    loadBalancing?: LoadBalancingPolicy;
    name: string;
    readTimeout?: number;
    retry?: RetryPolicy;
    serialConsistency?: consistencies;
}

// @public
export class ExponentialReconnectionPolicy extends ReconnectionPolicy {
    constructor(baseDelay: number, maxDelay: number, startWithNoDelay?: boolean);
    getOptions(): Map<string, any>;
    newSchedule(): Iterator<number>;
}

// @public
export class FallthroughRetryPolicy extends RetryPolicy {
    // Warning: (ae-forgotten-export) The symbol "OperationInfo" needs to be exported by the entry point cassandra-rollup.d.ts
    onReadTimeout(info: OperationInfo, consistency: consistencies, received: number, blockFor: number, isDataPresent: boolean): DecisionInfo;
    onRequestError(info: OperationInfo, consistency: consistencies, err: Error): DecisionInfo;
    onUnavailable(info: OperationInfo, consistency: consistencies, required: number, alive: number): DecisionInfo;
    onWriteTimeout(info: OperationInfo, consistency: consistencies, received: number, blockFor: number, writeType: string): DecisionInfo;
}

// @public (undocumented)
export type FindDocInfo = {
    fields?: string[];
    orderBy?: {
        [key: string]: string;
    };
    limit?: number;
};

// Warning: (ae-internal-missing-underscore) The name "frameFlags" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export const frameFlags: {
    compression: number;
    tracing: number;
    customPayload: number;
    warning: number;
};

// Warning: (ae-internal-missing-underscore) The name "FrameHeader" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class FrameHeader {
    constructor(version: number, flags: number, streamId: number, opcode: number, bodyLength: number);
    // (undocumented)
    bodyLength: number;
    // (undocumented)
    flags: number;
    // (undocumented)
    static fromBuffer(buf: Buffer, offset?: number): FrameHeader;
    static getProtocolVersion(buffer: Buffer): number;
    // (undocumented)
    opcode: number;
    static size(version: any): number;
    // (undocumented)
    streamId: number;
    // (undocumented)
    toBuffer(): Buffer;
    // (undocumented)
    version: number;
}

// Warning: (ae-internal-missing-underscore) The name "generateTimestamp" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function generateTimestamp(date: any, microseconds: any): Long__default;

// @public (undocumented)
export class Geometry {
    // @internal (undocumented)
    static getEndianness(code: number): string;
    // @internal
    static readDouble(buffer: Buffer, endianness: string, offset: number): number;
    // @internal
    static readInt32(buffer: Buffer, endianness: string, offset: number): number;
    // (undocumented)
    static types: {
        readonly Point2D: 1;
        readonly LineString: 2;
        readonly Polygon: 3;
    };
    // @internal
    useBESerialization(): boolean;
    // @internal
    writeDouble(val: number, buffer: Buffer, offset: number): void;
    // @internal
    writeEndianness(buffer: Buffer, offset: number): void;
    // @internal
    writeInt32(val: number, buffer: Buffer, offset: number): void;
}

// @public
export const geometry: {
    Point: typeof Point;
    LineString: typeof LineString;
    Polygon: typeof Polygon;
    Geometry: typeof Geometry;
};

// Warning: (ae-internal-missing-underscore) The name "getCustomTypeSerializers" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function getCustomTypeSerializers(): {};

// Warning: (ae-internal-missing-underscore) The name "getDataTypeNameByCode" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function getDataTypeNameByCode(item: any): any;

// @public (undocumented)
export const graph: {
    Edge: typeof Edge;
    Element: typeof Element;
    Path: typeof Path;
    Property: typeof Property;
    Vertex: typeof Vertex;
    VertexProperty: typeof VertexProperty;
    asInt: typeof asInt;
    asDouble: typeof asDouble;
    asFloat: typeof asFloat;
    asTimestamp: typeof asTimestamp;
    asUdt: typeof asUdt;
    direction: {
        both: EnumValue;
        in: EnumValue;
        out: EnumValue;
        in_: EnumValue;
    };
    getCustomTypeSerializers: typeof getCustomTypeSerializers;
    GraphResultSet: typeof GraphResultSet;
    GraphTypeWrapper: typeof GraphTypeWrapper;
    t: {
        id: EnumValue;
        key: EnumValue;
        label: EnumValue;
        value: EnumValue;
    };
    UdtGraphWrapper: typeof UdtGraphWrapper;
};

// @public
export class GraphResultSet implements Iterable<any> {
    [Symbol.iterator](): Iterator<any, any, any>;
    constructor(result: ResultSet, rowParser?: Function);
    first(): object | null;
    forEach(callback: Function, thisArg?: object): void;
    getTraversers(): IterableIterator<any>;
    // (undocumented)
    info: typeof ResultSet.prototype.info;
    // (undocumented)
    length: number;
    // (undocumented)
    pageState: string;
    toArray(): Array<any>;
    values(): Iterator<any>;
}

// Warning: (ae-internal-missing-underscore) The name "GraphTypeWrapper" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class GraphTypeWrapper {
    constructor(value: any, typeInfo: any);
    // (undocumented)
    typeInfo: any;
    // (undocumented)
    value: any;
}

// @public
export class Host extends EventEmitter.EventEmitter {
    // @internal
    constructor(address: any, protocolVersion: any, options: any, metadata: any);
    // (undocumented)
    address: string;
    // @internal
    borrowConnection(previousConnection?: Connection): Connection;
    canBeConsideredAsUp(): boolean;
    // (undocumented)
    cassandraVersion: string;
    // @internal
    checkHealth(connection: Connection): void;
    // @internal
    checkIsUp(): void;
    // (undocumented)
    datacenter: string;
    // @internal (undocumented)
    dseVersion: string;
    // @internal
    getActiveConnection(): Connection;
    getCassandraVersion(): Array<number>;
    getDseVersion(): Array<number>;
    // @internal
    getInFlight(): any;
    // @internal
    getResponseCount(): number;
    // (undocumented)
    hostId: Uuid;
    // @internal
    initializePool(): void;
    isUp(): boolean;
    // @internal (undocumented)
    isUpSince: number;
    // @internal (undocumented)
    options: any;
    // @internal (undocumented)
    pool: any;
    // (undocumented)
    rack: string;
    // @internal (undocumented)
    reconnectionSchedule: any;
    // @internal (undocumented)
    removeFromPool(connection: Connection): void;
    // @internal
    setDistance(distance: number): number;
    // @internal
    setDown(): void;
    // @internal
    setProtocolVersion(value: number): void;
    // @internal
    setUp(clearReconnection?: boolean): void;
    // @internal (undocumented)
    shutdown(waitForPending?: boolean): Promise<void>;
    // (undocumented)
    tokens: string[];
    // @internal
    warmupPool(keyspace: string): any;
    // @internal (undocumented)
    workloads: readonly any[];
}

// @public
export class HostMap extends EventEmitter.EventEmitter {
    // @internal
    constructor();
    // @internal
    clear(): Array<Host>;
    forEach(callback: (value: Host, key: string) => void): void;
    get(key: string): Host;
    // @internal (undocumented)
    inspect(): Map<any, any>;
    keys(): Array<string>;
    // (undocumented)
    length: number;
    // @internal @deprecated
    push(k: any, v: any): void;
    // @internal
    remove(key: string): void;
    // @internal
    removeMultiple(keys: Array<string>): void;
    // @internal
    set(key: string, value: Host): Host;
    // @internal
    slice(begin: number, end: number): Array<any>;
    // @internal (undocumented)
    toJSON(): any;
    values(): Array<Host>;
}

// @public @deprecated
export class IdempotenceAwareRetryPolicy extends RetryPolicy {
    // @deprecated
    constructor(childPolicy?: RetryPolicy);
    // (undocumented)
    onReadTimeout(info: OperationInfo, consistency: consistencies, received: number, blockFor: number, isDataPresent: boolean): DecisionInfo;
    // (undocumented)
    onRequestError(info: OperationInfo, consistency: consistencies, err: Error): DecisionInfo;
    // (undocumented)
    onUnavailable(info: OperationInfo, consistency: consistencies, required: number, alive: number): DecisionInfo;
    onWriteTimeout(info: OperationInfo, consistency: consistencies, received: number, blockFor: number, writeType: string): DecisionInfo;
}

// @public
export class Index {
    // @internal
    constructor(name: string, target: string, kind: number | string, options: object);
    // @internal @deprecated
    static fromColumnRows(columnRows: Array<Row>, columnsByName: {
        [key: string]: {
            name: any;
            type: any;
        };
    }): Array<Index>;
    // @internal @deprecated
    static fromRows(indexRows: Array<Row>): Array<Index>;
    isCompositesKind(): boolean;
    isCustomKind(): boolean;
    isKeysKind(): boolean;
    kind: IndexKind;
    name: string;
    options: object;
    target: string;
}

// @public (undocumented)
export enum IndexKind {
    // (undocumented)
    composites = 2,
    // (undocumented)
    custom = 0,
    // (undocumented)
    keys = 1
}

// @public
export class InetAddress {
    constructor(buffer: Buffer);
    equals(other: InetAddress): boolean;
    static fromString(value: string): InetAddress;
    getBuffer(): Buffer;
    // @internal
    inspect(): string;
    // (undocumented)
    length: number;
    toJSON(): string;
    toString(encoding?: string): string;
    // (undocumented)
    version: number;
}

// Warning: (ae-internal-missing-underscore) The name "init" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function init(options: ClientOptions): Promise<void>;

// @public (undocumented)
export type InsertDocInfo = {
    fields?: string[];
    ttl?: number;
    ifNotExists?: boolean;
};

// @public
export class Integer {
    constructor(bits: number[], sign: number);
    abs(): Integer;
    add(other: Integer): Integer;
    and(other: Integer): Integer;
    compare(other: Integer): number;
    divide(other: Integer): Integer;
    // (undocumented)
    equals(other: Integer): boolean;
    static fromBits(bits: number[]): Integer;
    static fromBuffer(buf: Buffer): Integer;
    static fromInt(value: number): Integer;
    static fromNumber(value: number): Integer;
    static fromString(str: string, opt_radix?: number): Integer;
    getBits(index: number): number;
    getBitsUnsigned(index: number): number;
    getSign(): number;
    // (undocumented)
    greaterThan(other: Integer): boolean;
    // (undocumented)
    greaterThanOrEqual(other: Integer): boolean;
    // @internal
    inspect(): string;
    isNegative(): boolean;
    isOdd(): boolean;
    isZero(): boolean;
    // (undocumented)
    lessThan(other: Integer): boolean;
    // (undocumented)
    lessThanOrEqual(other: Integer): boolean;
    modulo(other: Integer): Integer;
    multiply(other: Integer): Integer;
    negate(): Integer;
    not(): Integer;
    // (undocumented)
    notEquals(other: Integer): boolean;
    static ONE: Integer;
    or(other: Integer): Integer;
    shiftLeft(numBits: number): Integer;
    shiftRight(numBits: number): Integer;
    shorten(numBits: number): Integer;
    subtract(other: Integer): Integer;
    static toBuffer(value: Integer): Buffer;
    toInt(): number;
    toJSON(): string;
    toNumber(): number;
    // @override (undocumented)
    toString(opt_radix?: number): string;
    xor(other: Integer): Integer;
    static ZERO: Integer;
}

// @public
export class LineString extends Geometry {
    constructor(...points: Point[] | Point[][]);
    equals(other: LineString): boolean;
    static fromBuffer(buffer: Buffer): LineString;
    static fromString(textValue: string): LineString;
    // @internal
    static parseSegments(textValue: string): Point[];
    // @internal (undocumented)
    points: ReadonlyArray<Point>;
    toBuffer(): Buffer;
    toJSON(): object;
    toString(): string;
    // @internal
    useBESerialization(): boolean;
}

// @public (undocumented)
export const loadBalancing: {
    AllowListPolicy: typeof AllowListPolicy;
    DCAwareRoundRobinPolicy: typeof DCAwareRoundRobinPolicy;
    DefaultLoadBalancingPolicy: typeof DefaultLoadBalancingPolicy;
    LoadBalancingPolicy: typeof LoadBalancingPolicy;
    RoundRobinPolicy: typeof RoundRobinPolicy;
    TokenAwarePolicy: typeof TokenAwarePolicy;
    WhiteListPolicy: typeof WhiteListPolicy;
};

// @public
export class LoadBalancingPolicy {
    // (undocumented)
    protected client: Client;
    getDistance(host: Host): distance;
    getOptions(): Map<string, any>;
    // (undocumented)
    protected hosts: HostMap;
    init(client: Client, hosts: HostMap, callback: EmptyCallback): void;
    // @internal (undocumented)
    localDc: string;
    newQueryPlan(keyspace: string, executionOptions: ExecutionOptions, callback: (error: Error, iterator: Iterator<Host>) => void): void;
}

// @public
export class LocalDate {
    constructor(year: number, month?: number, day?: number);
    compare(other: LocalDate): number;
    date: Date;
    // (undocumented)
    day: number;
    equals(other: LocalDate): boolean;
    static fromBuffer(buffer: Buffer): LocalDate;
    static fromDate(date: Date): LocalDate;
    static fromString(value: string): LocalDate;
    // (undocumented)
    inspect(): string;
    // (undocumented)
    month: number;
    static now(): LocalDate;
    toBuffer(): Buffer;
    toJSON(): string;
    toString(): string;
    static utcNow(): LocalDate;
    // (undocumented)
    year: number;
}

// @public
export class LocalTime {
    constructor(totalNanoseconds: Long__default);
    compare(other: LocalTime): number;
    equals(other: LocalTime): boolean;
    static fromBuffer(value: Buffer): LocalTime;
    static fromDate(date: Date, nanoseconds?: number): LocalTime;
    static fromMilliseconds(milliseconds: number, nanoseconds?: number): LocalTime;
    static fromString(value: string): LocalTime;
    getTotalNanoseconds(): Long__default;
    hour: number;
    // (undocumented)
    inspect(): string;
    minute: number;
    nanosecond: number;
    static now(nanoseconds?: number): LocalTime;
    second: number;
    toBuffer(): Buffer;
    toJSON(): string;
    toString(): string;
}

export { Long }

// @public
export class Mapper {
    constructor(client: Client, options?: MappingOptions);
    batch(items: Array<ModelBatchItem>, executionOptions: string | MappingExecutionOptions): Promise<Result>;
    forModel<T = any>(name: string): ModelMapper<T>;
}

// @public (undocumented)
export const mapping: {
    Mapper: typeof Mapper;
    ModelMapper: typeof ModelMapper;
    ModelBatchMapper: typeof ModelBatchMapper;
    ModelBatchItem: typeof ModelBatchItem;
    Result: typeof Result;
    TableMappings: typeof TableMappings;
    DefaultTableMappings: typeof DefaultTableMappings;
    UnderscoreCqlToCamelCaseMappings: typeof UnderscoreCqlToCamelCaseMappings;
    q: {
        in_: (arr: any) => QueryOperator;
        gt: (value: any) => QueryOperator;
        gte: (value: any) => QueryOperator;
        lt: (value: any) => QueryOperator;
        lte: (value: any) => QueryOperator;
        notEq: (value: any) => QueryOperator;
        and: (condition1: any, condition2: any) => QueryOperator;
        incr: (value: any) => QueryAssignment;
        decr: (value: any) => QueryAssignment;
        append: (value: any) => QueryAssignment;
        prepend: (value: any) => QueryAssignment;
        remove: (value: any) => QueryAssignment;
    };
};

// @public (undocumented)
export type MappingExecutionOptions = {
    executionProfile?: string;
    isIdempotent?: boolean;
    logged?: boolean;
    timestamp?: number | Long__default;
    fetchSize?: number;
    pageState?: number;
};

// @public (undocumented)
export type MappingOptions = {
    models: {
        [key: string]: ModelOptions;
    };
};

// @public
export class MaterializedView extends DataCollection {
    // @internal
    constructor(name: string);
    includeAllColumns: boolean;
    tableName: string;
    whereClause: string;
}

// @public
export class Metadata {
    // @internal
    constructor(options: ClientOptions, controlConnection: ControlConnection);
    // @internal
    adaptUserHints(keyspace: string, hints: Array<any>): Promise<void>;
    // @internal
    buildTokens(hosts: HostMap): void;
    // @internal
    checkSchemaAgreement(callback: Function): Promise<any>;
    clearPrepared(): void;
    // @internal
    compareSchemaVersions(connection: Connection): Promise<boolean>;
    // @internal (undocumented)
    datacenters: {
        [datacenter: string]: {
            hostLength: number;
            racks: HashSet;
        };
    };
    getAggregate(keyspaceName: string, name: string, signature: string[] | Array<DataTypeInfo>, callback: ValueCallback<Aggregate>): void;
    // (undocumented)
    getAggregate(keyspaceName: string, name: string, signature: string[] | Array<DataTypeInfo>): Promise<Aggregate>;
    getAggregates(keyspaceName: string, name: string, callback: ValueCallback<Aggregate[]>): void;
    // (undocumented)
    getAggregates(keyspaceName: string, name: string): Promise<Aggregate[]>;
    // @internal (undocumented)
    getAllPrepared(): PreparedQueryInfo[];
    getFunction(keyspaceName: string, name: string, signature: string[] | Array<DataTypeInfo>, callback: ValueCallback<SchemaFunction>): void;
    // (undocumented)
    getFunction(keyspaceName: string, name: string, signature: string[] | Array<DataTypeInfo>): Promise<SchemaFunction>;
    getFunctions(keyspaceName: string, name: string, callback: ValueCallback<SchemaFunction[]>): void;
    // (undocumented)
    getFunctions(keyspaceName: string, name: string): Promise<SchemaFunction[]>;
    getMaterializedView(keyspaceName: string, name: string, callback: ValueCallback<MaterializedView>): void;
    // (undocumented)
    getMaterializedView(keyspaceName: string, name: string): Promise<MaterializedView>;
    // @internal (undocumented)
    getPreparedById(id: any): any;
    // @internal
    getPreparedInfo(keyspaceName: string, query: string): PreparedQueryInfo;
    getReplicas(keyspaceName: string, token: Buffer | Token | TokenRange): Array<Host>;
    getTable(keyspaceName: string, name: string, callback: ValueCallback<TableMetadata>): void;
    // (undocumented)
    getTable(keyspaceName: string, name: string): Promise<TableMetadata>;
    getTokenRanges(): Set<TokenRange>;
    getTokenRangesForHost(keyspaceName: string, host: Host): Set<TokenRange> | null;
    getTrace(traceId: Uuid, consistency: consistencies, callback: ValueCallback<QueryTrace>): void;
    // (undocumented)
    getTrace(traceId: Uuid, consistency: consistencies): Promise<QueryTrace>;
    // (undocumented)
    getTrace(traceId: Uuid, callback: ValueCallback<QueryTrace>): void;
    // (undocumented)
    getTrace(traceId: Uuid): Promise<QueryTrace>;
    getUdt(keyspaceName: string, name: string, callback: ValueCallback<Udt>): void;
    // (undocumented)
    getUdt(keyspaceName: string, name: string): Promise<Udt>;
    // @internal (undocumented)
    initialized: boolean;
    isDbaas(): boolean;
    // (undocumented)
    keyspaces: {
        [name: string]: Keyspace;
    };
    // @internal (undocumented)
    log: (type: string, info: string, furtherInfo?: any, options?: any) => void;
    newToken(components: Array<Buffer> | Buffer | string): Token;
    newTokenRange(start: Token, end: Token): TokenRange;
    // @internal (undocumented)
    primaryReplicas: Record<string, Host>;
    refreshKeyspace(name: string, callback: EmptyCallback): void;
    // (undocumented)
    refreshKeyspace(name: string): Promise<void>;
    refreshKeyspaces(waitReconnect: boolean, callback: EmptyCallback): void;
    // (undocumented)
    refreshKeyspaces(waitReconnect?: boolean): Promise<void>;
    // (undocumented)
    refreshKeyspaces(callback: EmptyCallback): void;
    // @internal (undocumented)
    refreshKeyspacesInternal(waitReconnect: boolean): Promise<{
        [s: string]: object;
    }>;
    // @internal (undocumented)
    ring: any[];
    // @internal (undocumented)
    ringTokensAsStrings: any[];
    // @internal
    setCassandraVersion(version: Array<number>): void;
    // Warning: (ae-forgotten-export) The symbol "Murmur3Tokenizer" needs to be exported by the entry point cassandra-rollup.d.ts
    // Warning: (ae-forgotten-export) The symbol "RandomTokenizer" needs to be exported by the entry point cassandra-rollup.d.ts
    // Warning: (ae-forgotten-export) The symbol "ByteOrderedTokenizer" needs to be exported by the entry point cassandra-rollup.d.ts
    //
    // @internal (undocumented)
    setPartitioner(partitionerName: string): Murmur3Tokenizer | RandomTokenizer | ByteOrderedTokenizer;
    // @internal (undocumented)
    setPreparedById(info: any): void;
    // @internal
    setProductTypeAsDbaas(): void;
    // Warning: (ae-forgotten-export) The symbol "Tokenizer" needs to be exported by the entry point cassandra-rollup.d.ts
    //
    // @internal (undocumented)
    tokenizer: Tokenizer;
    // @internal (undocumented)
    tokenRanges: Set<TokenRange>;
}

// @public (undocumented)
export const metadata: {
    Metadata: typeof Metadata;
};

// @public (undocumented)
export const metrics: {
    ClientMetrics: typeof ClientMetrics;
    DefaultMetrics: typeof DefaultMetrics;
};

// @public
export class ModelBatchItem {
    // @internal
    constructor(doc: object, docInfo: DocInfo, handler: MappingHandler, cache: Tree);
    // Warning: (ae-forgotten-export) The symbol "Tree" needs to be exported by the entry point cassandra-rollup.d.ts
    //
    // @internal (undocumented)
    cache: Tree;
    // @internal
    createQueries(docKeys: Array<any>): Promise<Array<any>>;
    // @internal (undocumented)
    doc: object;
    // Warning: (ae-forgotten-export) The symbol "DocInfo" needs to be exported by the entry point cassandra-rollup.d.ts
    //
    // @internal (undocumented)
    docInfo: DocInfo;
    // @internal
    getCacheKey(docKeys: Array<any>): Iterator<string>;
    // Warning: (ae-forgotten-export) The symbol "ModelMappingInfo" needs to be exported by the entry point cassandra-rollup.d.ts
    //
    // @internal
    getMappingInfo(): ModelMappingInfo;
    // @internal (undocumented)
    getQueries(): any;
    // Warning: (ae-forgotten-export) The symbol "MappingHandler" needs to be exported by the entry point cassandra-rollup.d.ts
    //
    // @internal (undocumented)
    handler: MappingHandler;
    // @internal
    pushQueries(arr: Array<any>): Promise<{
        isIdempotent: any;
        isCounter: any;
    }>;
}

// @public
export class ModelBatchMapper {
    // @internal
    constructor(handler: MappingHandler);
    insert(doc: object, docInfo: InsertDocInfo): ModelBatchItem;
    remove(doc: object, docInfo: RemoveDocInfo): ModelBatchItem;
    update(doc: object, docInfo: UpdateDocInfo): ModelBatchItem;
}

// @public (undocumented)
export type ModelColumnOptions = {
    name: string;
    toModel?: (columnValue: any) => any;
    fromModel?: (modelValue: any) => any;
};

// @public
export class ModelMapper<T = any> {
    // @internal
    constructor(name: any, handler: any);
    batching: ModelBatchMapper;
    find(doc: {
        [key: string]: any;
    }, docInfo?: FindDocInfo, executionOptions?: string | MappingExecutionOptions): Promise<Result<T>>;
    findAll(docInfo?: FindDocInfo, executionOptions?: string | MappingExecutionOptions): Promise<Result<T>>;
    get(doc: {
        [key: string]: any;
    }, docInfo?: {
        fields?: string[];
    }, executionOptions?: string | MappingExecutionOptions): Promise<null | T>;
    insert(doc: {
        [key: string]: any;
    }, docInfo?: InsertDocInfo, executionOptions?: string | MappingExecutionOptions): Promise<Result<T>>;
    mapWithQuery(query: string, paramsHandler: (doc: any) => any[], executionOptions?: string | MappingExecutionOptions): (doc: any, executionOptions?: string | MappingExecutionOptions) => Promise<Result<T>>;
    name: string;
    remove(doc: {
        [key: string]: any;
    }, docInfo?: RemoveDocInfo, executionOptions?: string | MappingExecutionOptions): Promise<Result<T>>;
    update(doc: {
        [key: string]: any;
    }, docInfo?: UpdateDocInfo, executionOptions?: string | MappingExecutionOptions): Promise<Result<T>>;
}

// @public (undocumented)
export type ModelOptions = {
    tables?: string[] | ModelTables[];
    mappings?: TableMappings;
    columns?: {
        [key: string]: string | ModelColumnOptions;
    };
    keyspace?: string;
};

// @public (undocumented)
export interface ModelTables {
    // (undocumented)
    isView: boolean;
    // (undocumented)
    name: string;
}

// @public
export class MonotonicTimestampGenerator extends TimestampGenerator {
    constructor(warningThreshold?: number, minLogInterval?: number);
    getDate(): number;
    // (undocumented)
    next(client: Client): Long__default | number | null;
}

// Warning: (ae-internal-missing-underscore) The name "NoAuthProvider" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class NoAuthProvider extends AuthProvider {
    // Warning: (ae-forgotten-export) The symbol "TransitionalModePlainTextAuthenticator" needs to be exported by the entry point cassandra-rollup.d.ts
    // Warning: (ae-forgotten-export) The symbol "NoAuthAuthenticator" needs to be exported by the entry point cassandra-rollup.d.ts
    //
    // (undocumented)
    newAuthenticator(endpoint: any, name: any): TransitionalModePlainTextAuthenticator | NoAuthAuthenticator;
}

// @public
export class NoHostAvailableError extends DriverError {
    constructor(innerErrors: object, message?: string);
    // (undocumented)
    innerErrors: object;
}

// @public
export class NoSpeculativeExecutionPolicy extends SpeculativeExecutionPolicy {
    constructor();
    // (undocumented)
    newPlan(keyspace: string, queryInfo: string | Array<string>): {
        nextExecution: () => number;
    };
}

// @public
export class NotSupportedError extends DriverError {
    constructor(message: string);
}

// Warning: (ae-internal-missing-underscore) The name "opcodes" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export const opcodes: {
    error: number;
    startup: number;
    ready: number;
    authenticate: number;
    credentials: number;
    options: number;
    supported: number;
    query: number;
    result: number;
    prepare: number;
    execute: number;
    register: number;
    event: number;
    batch: number;
    authChallenge: number;
    authResponse: number;
    authSuccess: number;
    cancel: number;
    isInRange: (code: any) => boolean;
};

// @public
export class OperationTimedOutError extends DriverError {
    constructor(message: string, host?: string);
    // (undocumented)
    host?: string;
}

// @public (undocumented)
export type Options = {
    collectResults?: boolean;
    concurrencyLevel?: number;
    executionProfile?: string;
    maxErrors?: number;
    raiseOnFirstError?: boolean;
};

// @public
export class Path {
    constructor(labels: any[], objects: any[]);
    // (undocumented)
    labels: any[];
    // (undocumented)
    objects: any[];
}

// @public
export class PlainTextAuthProvider extends AuthProvider {
    constructor(username: string, password: string);
    // @override
    newAuthenticator(): Authenticator;
}

// @public
export class Point extends Geometry {
    constructor(x: number, y: number);
    equals(other: Point): boolean;
    static fromBuffer(buffer: Buffer): Point;
    static fromString(textValue: string): Point;
    toBuffer(): Buffer;
    toJSON(): object;
    toString(): string;
    // @internal (undocumented)
    useBESerialization(): boolean;
    // @internal (undocumented)
    x: number;
    // @internal (undocumented)
    y: number;
}

// @public (undocumented)
export const policies: {
    addressResolution: {
        AddressTranslator: typeof AddressTranslator;
        EC2MultiRegionTranslator: typeof EC2MultiRegionTranslator;
    };
    loadBalancing: {
        AllowListPolicy: typeof AllowListPolicy;
        DCAwareRoundRobinPolicy: typeof DCAwareRoundRobinPolicy;
        DefaultLoadBalancingPolicy: typeof DefaultLoadBalancingPolicy;
        LoadBalancingPolicy: typeof LoadBalancingPolicy;
        RoundRobinPolicy: typeof RoundRobinPolicy;
        TokenAwarePolicy: typeof TokenAwarePolicy;
        WhiteListPolicy: typeof WhiteListPolicy;
    };
    reconnection: {
        ReconnectionPolicy: typeof ReconnectionPolicy;
        ConstantReconnectionPolicy: typeof ConstantReconnectionPolicy;
        ExponentialReconnectionPolicy: typeof ExponentialReconnectionPolicy;
    };
    retry: {
        IdempotenceAwareRetryPolicy: typeof IdempotenceAwareRetryPolicy;
        FallthroughRetryPolicy: typeof FallthroughRetryPolicy;
        RetryPolicy: typeof RetryPolicy;
    };
    speculativeExecution: {
        NoSpeculativeExecutionPolicy: typeof NoSpeculativeExecutionPolicy;
        SpeculativeExecutionPolicy: typeof SpeculativeExecutionPolicy;
        ConstantSpeculativeExecutionPolicy: typeof ConstantSpeculativeExecutionPolicy;
    };
    timestampGeneration: {
        TimestampGenerator: typeof TimestampGenerator;
        MonotonicTimestampGenerator: typeof MonotonicTimestampGenerator;
    };
    defaultAddressTranslator: () => AddressTranslator;
    defaultLoadBalancingPolicy: (localDc?: string) => LoadBalancingPolicy;
    defaultRetryPolicy: () => RetryPolicy;
    defaultReconnectionPolicy: () => ReconnectionPolicy;
    defaultSpeculativeExecutionPolicy: () => SpeculativeExecutionPolicy;
    defaultTimestampGenerator: () => TimestampGenerator;
};

// @public
export class Polygon extends Geometry {
    constructor(...ringPoints: Point[][]);
    equals(other: Polygon): boolean;
    static fromBuffer(buffer: Buffer): Polygon;
    static fromString(textValue: string): Polygon;
    // @internal (undocumented)
    rings: ReadonlyArray<ReadonlyArray<Point>>;
    toBuffer(): Buffer;
    toJSON(): object;
    toString(): string;
    // @internal (undocumented)
    useBESerialization(): boolean;
}

// @public (undocumented)
export type PreparedQueryInfo = {
    queryId?: Buffer;
    preparing?: boolean;
    query: string;
    keyspace: string;
    meta?: DataCollection;
} & EventEmitter_2;

// @public
export class Property {
    constructor(key: string, value: any);
    // (undocumented)
    key: string;
    // (undocumented)
    value: any;
}

// Warning: (ae-internal-missing-underscore) The name "protocolEvents" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export const protocolEvents: {
    topologyChange: string;
    statusChange: string;
    schemaChange: string;
};

// @public
export enum protocolVersion {
    // (undocumented)
    dseV1 = 65,
    // (undocumented)
    dseV2 = 66,
    // (undocumented)
    maxSupported = 66,
    // (undocumented)
    minSupported = 1,
    // (undocumented)
    v1 = 1,
    // (undocumented)
    v2 = 2,
    // (undocumented)
    v3 = 3,
    // (undocumented)
    v4 = 4,
    // (undocumented)
    v5 = 5,
    // (undocumented)
    v6 = 6
}

// @public (undocumented)
export namespace protocolVersion {
    // @internal
    export function canStartupResponseErrorBeWrapped(version: number): boolean;
    // @internal
    export function getHighestCommon(connection: Connection, hosts: HostMap): number;
    // @internal
    export function getLowerSupported(version: number): number;
    // @internal
    export function isBeta(version: number): boolean;
    // @internal
    export function isDse(version: number): boolean;
    export function isSupported(version: number): boolean;
    // @internal
    export function isSupportedCassandra(version: number): boolean;
    // @internal
    export function supportsContinuousPaging(version: any): boolean;
    // @internal
    export function supportsFailureReasonMap(version: any): boolean;
    // @internal
    export function supportsKeyspaceInRequest(version: number): boolean;
    // @internal
    export function supportsNamedParameters(version: number): boolean;
    // @internal
    export function supportsPaging(version: any): boolean;
    // @internal
    export function supportsPreparedPartitionKey(version: number): boolean;
    // @internal
    export function supportsPrepareFlags(version: number): boolean;
    // @internal
    export function supportsResultMetadataId(version: number): boolean;
    // @internal
    export function supportsSchemaChangeFullMetadata(version: any): boolean;
    // @internal
    export function supportsTimestamp(version: number): boolean;
    // @internal
    export function supportsUnset(version: number): boolean;
    // @internal
    export function uses2BytesStreamIds(version: number): boolean;
    // @internal
    export function uses4BytesCollectionLength(version: number): boolean;
    // @internal
    export function uses4BytesQueryFlags(version: number): boolean;
}

// @public
export const q: {
    in_: (arr: any) => QueryOperator;
    gt: (value: any) => QueryOperator;
    gte: (value: any) => QueryOperator;
    lt: (value: any) => QueryOperator;
    lte: (value: any) => QueryOperator;
    notEq: (value: any) => QueryOperator;
    and: (condition1: any, condition2: any) => QueryOperator;
    incr: (value: any) => QueryAssignment;
    decr: (value: any) => QueryAssignment;
    append: (value: any) => QueryAssignment;
    prepend: (value: any) => QueryAssignment;
    remove: (value: any) => QueryAssignment;
};

// @public
export interface QueryOptions {
    // (undocumented)
    autoPage?: boolean;
    // (undocumented)
    captureStackTrace?: boolean;
    // (undocumented)
    consistency?: consistencies;
    // (undocumented)
    counter?: boolean;
    // (undocumented)
    customPayload?: object;
    // (undocumented)
    executeAs?: string;
    // (undocumented)
    executionProfile?: string | ExecutionProfile;
    // (undocumented)
    fetchSize?: number;
    // (undocumented)
    graphOptions?: {
        language?: string;
        name?: string;
        readConsistency?: number;
        readTimeout?: number;
        source?: string;
        writeConsistency?: number;
    };
    // (undocumented)
    hints?: Array<string> | Array<Array<string>>;
    // (undocumented)
    host?: Host;
    // (undocumented)
    isIdempotent?: boolean;
    // (undocumented)
    keyspace?: string;
    // (undocumented)
    logged?: boolean;
    // (undocumented)
    pageState?: Buffer | string;
    // (undocumented)
    prepare?: boolean;
    // (undocumented)
    readTimeout?: number;
    // (undocumented)
    retry?: RetryPolicy;
    // (undocumented)
    routingIndexes?: number[];
    // (undocumented)
    routingKey?: Buffer | Buffer[];
    // (undocumented)
    routingNames?: string[];
    // (undocumented)
    serialConsistency?: number;
    // (undocumented)
    timestamp?: number | Long__default;
    // (undocumented)
    traceQuery?: boolean;
}

// @public (undocumented)
export interface QueryTrace {
    // (undocumented)
    clientAddress: string;
    // (undocumented)
    coordinator: InetAddress;
    // (undocumented)
    duration: number;
    // (undocumented)
    events: Array<{
        id: Uuid;
        activity: any;
        source: any;
        elapsed: any;
        thread: any;
    }>;
    // (undocumented)
    parameters: {
        [key: string]: any;
    };
    // (undocumented)
    requestType: string;
    // (undocumented)
    startedAt: number | Long__default;
}

// @public (undocumented)
export const reconnection: {
    ReconnectionPolicy: typeof ReconnectionPolicy;
    ConstantReconnectionPolicy: typeof ConstantReconnectionPolicy;
    ExponentialReconnectionPolicy: typeof ExponentialReconnectionPolicy;
};

// @public
export class ReconnectionPolicy {
    constructor();
    getOptions(): Map<string, any>;
    newSchedule(): Iterator<number>;
}

// @public (undocumented)
export type RemoveDocInfo = {
    fields?: string[];
    ttl?: number;
    ifExists?: boolean;
    when?: {
        [key: string]: any;
    };
    deleteOnlyColumns?: boolean;
};

// @public
export class RequestLogger extends RequestTracker {
    constructor(options: {
        slowThreshold?: number;
        requestSizeThreshold?: number;
        logNormalRequests?: boolean;
        logErroredRequests?: boolean;
        messageMaxQueryLength?: number;
        messageMaxParameterValueLength?: number;
        messageMaxErrorStackTraceLength?: number;
    });
    // @override
    onError(host: Host, query: string | Array<{
        query: string;
        params?: any;
    }>, parameters: any[] | {
        [p: string]: any;
    } | null, executionOptions: ExecutionOptions, requestLength: number, err: Error, latency: number[]): void;
    // @override
    onSuccess(host: Host, query: string | Array<{
        query: string;
        params?: any;
    }>, parameters: any[] | {
        [p: string]: any;
    } | null, executionOptions: ExecutionOptions, requestLength: number, responseLength: number, latency: number[]): void;
}

// @public
export class RequestTracker {
    onError?(host: Host, query: string | Array<{
        query: string;
        params?: any;
    }>, parameters: any[] | {
        [key: string]: any;
    } | null, executionOptions: ExecutionOptions, requestLength: number, err: Error, latency: number[]): void;
    onSuccess?(host: Host, query: string | Array<{
        query: string;
        params?: any;
    }>, parameters: any[] | {
        [key: string]: any;
    } | null, executionOptions: ExecutionOptions, requestLength: number, responseLength: number, latency: number[]): void;
    shutdown?(): void;
}

// @public
export class ResponseError extends DriverError {
    constructor(code: number, message: string);
    // (undocumented)
    alive?: number;
    // (undocumented)
    argTypes?: string[];
    // (undocumented)
    blockFor?: number;
    // (undocumented)
    code: number;
    // (undocumented)
    consistencies?: consistencies;
    // (undocumented)
    failures?: number;
    // (undocumented)
    functionName?: string;
    // (undocumented)
    isDataPresent?: any;
    // (undocumented)
    keyspace?: string;
    // (undocumented)
    queryId?: any;
    // (undocumented)
    reasons?: object;
    // (undocumented)
    received?: number;
    // (undocumented)
    required?: number;
    // (undocumented)
    table?: string;
    // (undocumented)
    writeType?: any;
}

// @public
export enum responseErrorCodes {
    // (undocumented)
    alreadyExists = 9216,
    // (undocumented)
    badCredentials = 256,
    // (undocumented)
    clientWriteFailure = 32768,
    // (undocumented)
    configError = 8960,
    // (undocumented)
    functionFailure = 5120,
    // (undocumented)
    invalid = 8704,
    // (undocumented)
    isBootstrapping = 4098,
    // (undocumented)
    overloaded = 4097,
    // (undocumented)
    protocolError = 10,
    // (undocumented)
    readFailure = 4864,
    // (undocumented)
    readTimeout = 4608,
    // (undocumented)
    serverError = 0,
    // (undocumented)
    syntaxError = 8192,
    // (undocumented)
    truncateError = 4099,
    // (undocumented)
    unauthorized = 8448,
    // (undocumented)
    unavailableException = 4096,
    // (undocumented)
    unprepared = 9472,
    // (undocumented)
    writeFailure = 5376,
    // (undocumented)
    writeTimeout = 4352
}

// @public
export class Result<T = any> implements IterableIterator<T> {
    // (undocumented)
    [inspectMethod](): T[];
    [Symbol.iterator](): IterableIterator<T>;
    // @internal
    constructor(rs: ResultSet, info: ModelMappingInfo, rowAdapter: Function);
    first(): T | null;
    forEach(callback: (currentValue: T, index: number) => void, thisArg: any): void;
    // @internal (undocumented)
    length: number;
    // (undocumented)
    next(): {
        done: boolean;
        value: T;
    };
    // @internal (undocumented)
    pageState: string;
    toArray(): T[];
    wasApplied(): boolean;
}

// Warning: (ae-internal-missing-underscore) The name "resultKind" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export const resultKind: {
    voidResult: number;
    rows: number;
    setKeyspace: number;
    prepared: number;
    schemaChange: number;
};

// @public
export class ResultSet implements Iterable<Row>, AsyncIterable<Row> {
    [Symbol.asyncIterator](): AsyncIterator<Row>;
    [Symbol.iterator](): Iterator<Row>;
    // @internal
    constructor(response: {
        rows: Array<any>;
        flags: {
            traceId: Uuid;
            warnings: string[];
            customPayload: any;
        };
        meta?: {
            columns: Array<{
                name: string;
                type: DataTypeInfo;
            }>;
            pageState: Buffer;
        };
    }, host: string, triedHosts: {
        [key: string]: any;
    }, speculativeExecutions: number, consistency: consistencies, isSchemaInAgreement: boolean);
    // (undocumented)
    columns: Array<{
        name: string;
        type: DataTypeInfo;
    }>;
    first(): Row;
    // (undocumented)
    getColumns(): Array<{
        name: string;
        type: DataTypeInfo;
    }>;
    // (undocumented)
    getPageState(): string;
    // (undocumented)
    info: {
        queriedHost: string;
        triedHosts: {
            [key: string]: any;
        };
        speculativeExecutions: number;
        achievedConsistency: consistencies;
        traceId: Uuid;
        warnings: string[];
        customPayload: any;
        isSchemaInAgreement: boolean;
    };
    isPaged(): boolean;
    // (undocumented)
    nextPage: (() => void) | null;
    // @internal (undocumented)
    nextPageAsync: Function | undefined;
    // (undocumented)
    pageState: string;
    // @internal (undocumented)
    rawPageState: any;
    // (undocumented)
    rowLength: number;
    // (undocumented)
    rows: Row[];
    wasApplied(): boolean;
}

// @public
export class ResultSetGroup {
    // @internal
    constructor(options: any);
    // (undocumented)
    errors: Error[];
    // (undocumented)
    resultItems: any[];
    // @internal
    setError(index: any, err: any): void;
    // @internal (undocumented)
    setResultItem(index: any, rs: any): void;
    // (undocumented)
    totalExecuted: number;
}

// @public
export class ResultStream extends Readable {
    // @internal
    constructor(opt: any);
    // (undocumented)
    add(chunk: any): number;
    // (undocumented)
    buffer: any[];
    // @internal
    cancel(callback: Function): any;
    // (undocumented)
    paused: boolean;
    // @internal (undocumented)
    _read(): void;
    // @internal
    setHandlers(options: any): void;
    // @internal
    _valve(readNext: Function): void;
}

// @public (undocumented)
export const retry: {
    IdempotenceAwareRetryPolicy: typeof IdempotenceAwareRetryPolicy;
    FallthroughRetryPolicy: typeof FallthroughRetryPolicy;
    RetryPolicy: typeof RetryPolicy;
};

// @public
export class RetryPolicy {
    onReadTimeout(info: OperationInfo, consistency: consistencies, received: number, blockFor: number, isDataPresent: boolean): DecisionInfo;
    onRequestError(info: OperationInfo, consistency: consistencies, err: Error): DecisionInfo;
    onUnavailable(info: OperationInfo, consistency: consistencies, required: number, alive: number): DecisionInfo;
    onWriteTimeout(info: OperationInfo, consistency: consistencies, received: number, blockFor: number, writeType: string): DecisionInfo;
    rethrowResult(): DecisionInfo;
    retryResult(consistency?: consistencies, useCurrentHost?: boolean): DecisionInfo;
}

// @public
export namespace RetryPolicy {
    // (undocumented)
    export enum retryDecision {
        // (undocumented)
        ignore = 2,
        // (undocumented)
        rethrow = 0,
        // (undocumented)
        retry = 1
    }
}

// @public
export class RoundRobinPolicy extends LoadBalancingPolicy {
    constructor();
    newQueryPlan(keyspace: string, executionOptions: ExecutionOptions, callback: (error: Error, iterator: Iterator<Host>) => void): void;
}

// @public
export class Row {
    // @internal
    constructor(columns: Array<any>);
    // (undocumented)
    [key: string]: any;
    forEach(callback: (val: any, key: string) => void): void;
    get(columnName: string | number): any;
    keys(): string[];
    values(): Array<any>;
}

// @public
export class SchemaFunction {
    // @internal
    constructor();
    argumentNames: Array<string>;
    argumentTypes: Array<DataTypeInfo>;
    body: string;
    calledOnNullInput: boolean;
    deterministic: boolean;
    keyspaceName: string;
    language: string;
    monotonic: boolean;
    monotonicOn: Array<string>;
    name: string;
    returnType: DataTypeInfo;
    signature: Array<string>;
}

// @public
export const search: {
    DateRange: typeof DateRange;
    DateRangeBound: typeof DateRangeBound;
    dateRangePrecision: {
        readonly year: 0;
        readonly month: 1;
        readonly day: 2;
        readonly hour: 3;
        readonly minute: 4;
        readonly second: 5;
        readonly millisecond: 6;
    };
};

// @public (undocumented)
export const speculativeExecution: {
    NoSpeculativeExecutionPolicy: typeof NoSpeculativeExecutionPolicy;
    SpeculativeExecutionPolicy: typeof SpeculativeExecutionPolicy;
    ConstantSpeculativeExecutionPolicy: typeof ConstantSpeculativeExecutionPolicy;
};

// @public
export class SpeculativeExecutionPolicy {
    constructor();
    getOptions(): Map<string, any>;
    init(client: Client): void;
    newPlan(keyspace: string, queryInfo: string | Array<string>): {
        nextExecution: () => number;
    };
    shutdown(): void;
}

// @public
export const t: {
    id: EnumValue;
    key: EnumValue;
    label: EnumValue;
    value: EnumValue;
};

// @public
export class TableMappings {
    getColumnName(propName: string): string;
    getPropertyName(columnName: string): string;
    newObjectInstance(): object;
}

// @public
export class TableMetadata extends DataCollection {
    // @internal
    constructor(name: string);
    cdc?: boolean;
    indexes: Array<Index>;
    indexInterval?: number;
    isCompact: boolean;
    memtableFlushPeriod: number;
    replicateOnWrite: boolean;
    virtual: boolean;
}

// @public (undocumented)
export class TimeoutError extends errors.DriverError {
    constructor(message: string);
}

// @public (undocumented)
export const timestampGeneration: {
    TimestampGenerator: typeof TimestampGenerator;
    MonotonicTimestampGenerator: typeof MonotonicTimestampGenerator;
};

// @public
export class TimestampGenerator {
    constructor();
    next(client: Client): Long__default | number | null;
}

// @public
export class TimeUuid extends Uuid {
    constructor(value: Date | Buffer, ticks?: number, nodeId?: string | Buffer, clockId?: string | Buffer);
    static fromDate(date: Date, ticks?: number, nodeId?: string | Buffer, clockId?: string | Buffer): TimeUuid;
    // (undocumented)
    static fromDate(date: Date, ticks: number, nodeId: string | Buffer, clockId: string | Buffer, callback: ValueCallback<TimeUuid>): void;
    static fromString(value: string): TimeUuid;
    getClockId(): Buffer;
    getDate(): Date;
    getDatePrecision(): {
        date: Date;
        ticks: number;
    };
    getNodeId(): Buffer;
    getNodeIdString(): string;
    static max(date: Date, ticks?: number): TimeUuid;
    static min(date: Date, ticks?: number): TimeUuid;
    static now(): TimeUuid;
    // (undocumented)
    static now(nodeId: string | Buffer, clockId?: string | Buffer): TimeUuid;
    // (undocumented)
    static now(nodeId: string | Buffer, clockId: string | Buffer, callback: ValueCallback<TimeUuid>): void;
    // (undocumented)
    static now(callback: ValueCallback<TimeUuid>): void;
}

// @public @deprecated
export function timeuuid(options: {
    msecs: any;
    node: any;
    clockseq: any;
    nsecs: any;
}, buffer: Buffer, offset: number): string | Buffer;

// @public (undocumented)
export const token: {
    Token: typeof Token;
    TokenRange: typeof TokenRange;
};

// @public
export class TokenAwarePolicy extends LoadBalancingPolicy {
    constructor(childPolicy: LoadBalancingPolicy);
    // (undocumented)
    getDistance(host: Host): distance;
    // (undocumented)
    getOptions(): Map<string, any>;
    // (undocumented)
    init(client: Client, hosts: HostMap, callback: EmptyCallback): void;
    newQueryPlan(keyspace: string, executionOptions: ExecutionOptions, callback: (error: Error, iterator: Iterator<Host>) => void): void;
}

// @public
export const tracker: {
    RequestTracker: typeof RequestTracker;
    RequestLogger: typeof RequestLogger;
};

// @public
export class Tuple {
    constructor(...args: any[]);
    // (undocumented)
    elements: any[];
    static fromArray(elements: any[]): Tuple;
    get(index: number): any;
    // (undocumented)
    length: number;
    toJSON(): any[];
    toString(): string;
    values(): any[];
}

// @public (undocumented)
export const types: {
    opcodes: {
        error: number;
        startup: number;
        ready: number;
        authenticate: number;
        credentials: number;
        options: number;
        supported: number;
        query: number;
        result: number;
        prepare: number;
        execute: number;
        register: number;
        event: number;
        batch: number;
        authChallenge: number;
        authResponse: number;
        authSuccess: number;
        cancel: number;
        isInRange: (code: any) => boolean;
    };
    consistencies: typeof consistencies;
    consistencyToString: {};
    dataTypes: typeof dataTypes;
    getDataTypeNameByCode: typeof getDataTypeNameByCode;
    distance: typeof distance;
    frameFlags: {
        compression: number;
        tracing: number;
        customPayload: number;
        warning: number;
    };
    protocolEvents: {
        topologyChange: string;
        statusChange: string;
        schemaChange: string;
    };
    protocolVersion: typeof protocolVersion;
    responseErrorCodes: typeof responseErrorCodes;
    resultKind: {
        voidResult: number;
        rows: number;
        setKeyspace: number;
        prepared: number;
        schemaChange: number;
    };
    timeuuid: typeof timeuuid;
    uuid: typeof uuid;
    BigDecimal: typeof BigDecimal;
    Duration: typeof Duration;
    FrameHeader: typeof FrameHeader;
    InetAddress: typeof InetAddress;
    Integer: typeof Integer;
    LocalDate: typeof LocalDate;
    LocalTime: typeof LocalTime;
    Long: typeof Long__default;
    ResultSet: typeof ResultSet;
    ResultStream: typeof ResultStream;
    Row: typeof Row;
    DriverError: typeof DriverError;
    TimeoutError: typeof TimeoutError;
    TimeUuid: typeof TimeUuid;
    Tuple: typeof Tuple;
    Uuid: typeof Uuid;
    unset: Readonly<{
        readonly unset: true;
    }>;
    generateTimestamp: typeof generateTimestamp;
    Vector: typeof Vector;
};

// @public (undocumented)
export interface Udt {
    // (undocumented)
    fields: ColumnInfo[];
    // (undocumented)
    name: string;
}

// Warning: (ae-internal-missing-underscore) The name "UdtGraphWrapper" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class UdtGraphWrapper {
    constructor(value: any, udtInfo: any);
    // (undocumented)
    udtInfo: any;
    // (undocumented)
    value: any;
}

// @public
export class UnderscoreCqlToCamelCaseMappings extends TableMappings {
    constructor();
    getColumnName(propName: string): string;
    getPropertyName(columnName: string): string;
}

// @public
export const unset: Readonly<{
    readonly unset: true;
}>;

// @public (undocumented)
export type UpdateDocInfo = {
    fields?: string[];
    ttl?: number;
    ifExists?: boolean;
    when?: {
        [key: string]: any;
    };
    orderBy?: {
        [key: string]: string;
    };
    limit?: number;
    deleteOnlyColumns?: boolean;
};

// @public
export class Uuid {
    constructor(buffer: Buffer);
    // @internal (undocumented)
    buffer: Buffer;
    equals(other: Uuid): boolean;
    static fromString(value: string): Uuid;
    getBuffer(): Buffer;
    inspect(): string;
    static random(): Uuid;
    // (undocumented)
    static random(callback: ValueCallback<Uuid>): void;
    toJSON(): string;
    toString(): string;
}

// @public @deprecated
export function uuid(options: any, buffer: any, offset: any): any;

// @public (undocumented)
export class Vector {
    // (undocumented)
    [Symbol.iterator](): IterableIterator<any>;
    // (undocumented)
    static get [Symbol.species](): typeof Vector;
    constructor(elements: Float32Array | Array<any>, subtype?: string);
    // (undocumented)
    at(index: number): any;
    // (undocumented)
    elements: any[];
    // (undocumented)
    forEach(callback: (value: any, index: number, array: any[]) => void): void;
    // (undocumented)
    getSubtype(): string | null;
    length: number;
    // (undocumented)
    subtype: string;
    toString(): string;
}

// @public (undocumented)
export const version: string;

// @public
export class Vertex extends Element {
    constructor(id: any, label: string, properties?: {
        [key: string]: any[];
    });
    // (undocumented)
    properties: {
        [key: string]: any[];
    };
}

// @public
export class VertexProperty extends Element {
    constructor(id: any, label: string, value: any, properties: object);
    // (undocumented)
    key: string;
    // (undocumented)
    properties: any;
    // (undocumented)
    value: any;
}

// @public
export class VIntOutOfRangeException extends DriverError {
    constructor(long: Long__default);
}

// @public @deprecated
export class WhiteListPolicy extends AllowListPolicy {
    // @deprecated
    constructor(childPolicy: LoadBalancingPolicy, allowList: Array<string>);
}

// Warnings were encountered during analysis:
//
// out/cassandra-rollup.d.ts:2970:9 - (ae-forgotten-export) The symbol "Keyspace" needs to be exported by the entry point cassandra-rollup.d.ts
// out/cassandra-rollup.d.ts:2993:13 - (ae-forgotten-export) The symbol "HashSet" needs to be exported by the entry point cassandra-rollup.d.ts
// out/cassandra-rollup.d.ts:4511:9 - (ae-forgotten-export) The symbol "AddressResolver" needs to be exported by the entry point cassandra-rollup.d.ts
// out/cassandra-rollup.d.ts:7591:5 - (ae-forgotten-export) The symbol "EnumValue" needs to be exported by the entry point cassandra-rollup.d.ts
// out/cassandra-rollup.d.ts:9425:13 - (ae-forgotten-export) The symbol "QueryOperator" needs to be exported by the entry point cassandra-rollup.d.ts
// out/cassandra-rollup.d.ts:9432:13 - (ae-forgotten-export) The symbol "QueryAssignment" needs to be exported by the entry point cassandra-rollup.d.ts
// out/cassandra-rollup.d.ts:9452:9 - (ae-forgotten-export) The symbol "Token" needs to be exported by the entry point cassandra-rollup.d.ts
// out/cassandra-rollup.d.ts:9453:9 - (ae-forgotten-export) The symbol "TokenRange" needs to be exported by the entry point cassandra-rollup.d.ts

// (No @packageDocumentation comment for this package)

```
